/*
 * CREATED BY SHAIL MURTAZA
 * Start Date: Friday Feb 11, 2022
 * End Date: Sunday Feb 13, 2022
*/


/*
* > Increment Pointer
* < Decrement Pointer
* - Decrement Value in Current Pointer
* + Decrement Value in Current Pointer
* . Print Value in Current Pointer as Character
* { Print Value in Current Pointer as Integer (Very Useful while debugging)
* , Input Value as Charachter
* } Input Value as Integer
* 
* Difference Between traditional BrainFuck Compiler and this one
* 
* BrainFuck Compiler uses fixed size of 1 byte array to store data.
* If you will use more than allocated memory than your program could crash.
* And usage of less memory than allocated is wastage of memory.
* Mine Compiler uses dynamically allocated array which increases size of array according to need
* 
* This compiler Provides input and output feature as Integer
* 
* C source code generated by this compiler is more readable
*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define TEMP_BUFF 100
#define LESS_ARGUMENTS 1
#define FILE_READ_ERROR 2
#define FILE_WRITE_ERROR 3

void usage(char *filename); // Print Usage
char *read_source(char *filename); // Read the source file and returns pointer of the source code
char *clean(char *file_data); // Remove unwanted  characters
char *generate(char *file_data, char *filename); // Convert BrainFuck source code C source code and save in file
void compile(char *filename_c, char *out_filename); // Compile generated C source code

	
int main(int argc, char *argv[]) {
	if (argc < 3) {
		usage(argv[0]);
		exit(LESS_ARGUMENTS);
	}
	char *out_filename = argv[2];
	char *file_data = read_source(argv[1]);
	file_data = clean(file_data);
	char *filename_c = generate(file_data, out_filename);
	compile(filename_c, out_filename);
	// puts("Compilation finished successfully");
	return 0;
}

char *read_source(char *filename) {
	char temp_data[TEMP_BUFF]; // This will hold temporary data readed from file
	size_t data_len = 1; // Not length of data but number of allocated bytes in memory
	char *file_data = (char *) calloc(data_len, sizeof (char));	
	FILE *in_file = fopen(filename, "r");

	if (!in_file) {
		puts("File reading ERROR");
		exit(FILE_READ_ERROR);
	}

	while ( fgets(temp_data, TEMP_BUFF, in_file) ) {
		data_len += strlen(temp_data);
		file_data = (char *) realloc(file_data, data_len);
		strcat(file_data, temp_data);
	}
	fclose(in_file);
	return file_data;
}

char *clean(char *raw_file_data) {
	char keywords[] = ".,{}+-><[]", ch;
	size_t data_len = 1; // Not length of data but number of allocated bytes in memory
	char *file_data = (char *) calloc(data_len, sizeof (char));
	for(size_t i=0;i<strlen(raw_file_data);i++) {
	    ch = raw_file_data[i];
	    if (strchr(keywords, ch)) {
	        data_len++;
	        file_data = realloc(file_data, data_len);
	        file_data[data_len-2] = ch;
	        file_data[data_len-1] = 0;
	    }
	}
	free(raw_file_data);
	return file_data;
}

char *generate(char *file_data, char *filename) {
	char *filename_c = (char *) malloc(strlen(filename) + 3);
	size_t num = 0;
	sprintf(filename_c, "%s.c", filename);
	size_t i;
	FILE *out_file = fopen(filename_c, "w");
	if (!out_file) {
		puts("File write ERROR");
		exit(FILE_WRITE_ERROR);
	}

	fputs("#include <stdio.h>\n#include <stdlib.h>\n\nsize_t size_ptr=1, position_ptr=0;\nchar *ptr;\n\n", out_file);
	fputs("void increment_ptr(size_t n) {\n\tposition_ptr += n;\n\tif (position_ptr > size_ptr-1) {\n\t\tsize_ptr += n;\n\t\tptr = (char *) realloc(ptr, size_ptr);\n\t\tif (ptr == NULL) {\n\t\t\tputs(\"Reallocation Failed\");\n\t\t\tposition_ptr -= n;\n\t\t\tsize_ptr -= n;\n\t\t\treturn;\n\t\t}\n\t\t*(ptr + position_ptr) = 0;\n\t}\n}\n", out_file);
	fputs("void decrement_ptr(size_t n) {\n\tif (position_ptr) position_ptr -= n;\n}\n", out_file);
	fputs("int main() {\n\tptr = (char *) calloc(1, size_ptr);\n\tif(ptr == NULL) {\n\t\tputs(\"Memory Allocation Failed\");\n\t\treturn 1;\n\t}\n\n", out_file);
	for(i=0;i<strlen(file_data);i++) {
		switch(file_data[i]) {
			case '.':
				fputs("\tputchar(*(ptr + position_ptr));\n", out_file);
				break;
			case '{':
				fputs("\tprintf(\"%d\", *(ptr + position_ptr));\n", out_file);
				break;
			case ',':
				fputs("\t*(ptr + position_ptr) = getchar();\n", out_file);
				break;
			case '}':
				fputs("\tscanf(\"%hhd\", (ptr + position_ptr));\n", out_file);
				break;	
			case '+':
				num++;
				if (file_data[i+1] != '+') {
					fprintf(out_file, "\t(*(ptr + position_ptr)) += %lu;\n", num);
					num = 0;
				}
				break;
			case '-':
				num++;
				if (file_data[i+1] != '-') {
					fprintf(out_file, "\t(*(ptr + position_ptr)) -= %lu;\n", num);
					num = 0;
				}
				break;
			case '>':
				num++;
				if (file_data[i+1] != '>') {
					fprintf(out_file, "\tincrement_ptr(%lu);\n", num);
					num = 0;
				}
				break;
			case '<':
				num++;
				if (file_data[i+1] != '<') {
					fprintf(out_file, "\tdecrement_ptr(%lu);\n", num);
					num = 0;
				}
				break;
			case '[':
				fputs("\twhile(*(ptr+position_ptr)) {\n", out_file);
				break;
			case ']':
				fputs("\t}\n", out_file);
				break;
		}
	}
	fputs("\treturn 0;\n}", out_file);

	fclose(out_file);
	return filename_c;
}

void compile(char *filename_c, char *out_filename) {
	size_t len = strlen(filename_c) + strlen(out_filename);
	char *cmd = malloc(12 + (len * sizeof(char)) + 1);
	sprintf(cmd, "gcc -Wall %s -o %s", filename_c, out_filename);
	system(cmd);
	free(cmd);
}

void usage(char *filename) {
	printf("USAGE: [*] %s source.bf output.exe\n", filename);
}
